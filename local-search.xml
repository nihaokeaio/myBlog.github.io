<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/myblog.github.io/2024/07/06/hello-world/"/>
    <url>/myblog.github.io/2024/07/06/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>nlohmann-json使用</title>
    <link href="/myblog.github.io/2024/07/04/nlohmann-json%E4%BD%BF%E7%94%A8/"/>
    <url>/myblog.github.io/2024/07/04/nlohmann-json%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="nlohmann使用"><a href="#nlohmann使用" class="headerlink" title="nlohmann使用"></a>nlohmann使用</h1><h2 id="1-引言"><a href="#1-引言" class="headerlink" title="1. 引言"></a>1. 引言</h2><ul><li>nlohmann 是一个用于解析 JSON 的开源 C++ 库</li></ul><h2 id="2-使用"><a href="#2-使用" class="headerlink" title="2. 使用"></a>2. 使用</h2><h3 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;nlohmann/json.hpp&quot;</span></span><br></code></pre></td></tr></table></figure><p>通常也会直接解引用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">using</span> json = nlohmann::json;<br></code></pre></td></tr></table></figure><p>常见的使用手法详见  <a href="https://www.cnblogs.com/linuxAndMcu/p/14503341.html">常见json的使用方法</a></p><h2 id="3-自定义类型的转换"><a href="#3-自定义类型的转换" class="headerlink" title="3.自定义类型的转换"></a>3.自定义类型的转换</h2><p>比如定义如下的结构体</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"># --foo.cpp<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">OrderMesh</span><br>&#123;<br>    <span class="hljs-type">int</span> x;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; vec;<br>    Matrix mat;<br>&#125;;<br></code></pre></td></tr></table></figure><p>对于自定义类型，nlohmann可以直接解析，但是对于矩阵类型，nlohmann没有现成的方式来解析他，所以我们需要自己写一个解析方式来告诉它应该如何解析。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c++">#--jsonPrarse.h<br><br><span class="hljs-keyword">namespace</span> core<br>&#123;<br>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">adl_serializer</span>&lt;core::Point3&lt;T&gt;&gt; &#123;<br><br>    <span class="hljs-comment">//解析json到结构体</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br>    <span class="hljs-comment">//解析Point4&lt;T&gt;类型</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">adl_serializer</span>&lt;core::Point4&lt;T&gt;&gt; &#123;<br><span class="hljs-function"><span class="hljs-type">static</span> core::Point4&lt;T&gt; <span class="hljs-title">from_json</span><span class="hljs-params">(<span class="hljs-type">const</span> json&amp; j)</span> </span>&#123;<br><span class="hljs-function">core::Point4&lt;T&gt; <span class="hljs-title">p</span><span class="hljs-params">(j[<span class="hljs-string">&quot;value0&quot;</span>], j[<span class="hljs-string">&quot;value1&quot;</span>], j[<span class="hljs-string">&quot;value2&quot;</span>], j[<span class="hljs-string">&quot;value3&quot;</span>])</span></span>;<br><span class="hljs-keyword">return</span> std::<span class="hljs-built_in">move</span>(p);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">to_json</span><span class="hljs-params">(json&amp; j, <span class="hljs-type">const</span> core::Point4&lt;T&gt;&amp; u)</span> </span>&#123;<br>j[<span class="hljs-string">&quot;value0&quot;</span>] = u.<span class="hljs-built_in">X</span>();<br>j[<span class="hljs-string">&quot;value1&quot;</span>] = u.<span class="hljs-built_in">Y</span>();<br>j[<span class="hljs-string">&quot;value2&quot;</span>] = u.<span class="hljs-built_in">Z</span>();<br>j[<span class="hljs-string">&quot;value3&quot;</span>] = u.<span class="hljs-built_in">W</span>();<br>&#125;<br>    &#125;;<br><br>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">adl_serializer</span>&lt;core::Matrix44&lt;T&gt;&gt; &#123;<br><span class="hljs-function"><span class="hljs-type">static</span> core::Matrix44&lt;T&gt; <span class="hljs-title">from_json</span><span class="hljs-params">(<span class="hljs-type">const</span> json&amp; j)</span> </span>&#123;<br>core::Matrix44&lt;T&gt; mat;<br>core::Point4&lt;T&gt; v0, v1, v2, v3;<br>v0 = j.<span class="hljs-built_in">value</span>(<span class="hljs-string">&quot;value0&quot;</span>, v0);<br>v1 = j.<span class="hljs-built_in">value</span>(<span class="hljs-string">&quot;value1&quot;</span>, v1);<br>v2 = j.<span class="hljs-built_in">value</span>(<span class="hljs-string">&quot;value2&quot;</span>, v2);<br>v3 = j.<span class="hljs-built_in">value</span>(<span class="hljs-string">&quot;value3&quot;</span>, v3);<br>mat.<span class="hljs-built_in">SetColumn</span>(<span class="hljs-number">0</span>, v0);<br>mat.<span class="hljs-built_in">SetColumn</span>(<span class="hljs-number">1</span>, v1);<br>mat.<span class="hljs-built_in">SetColumn</span>(<span class="hljs-number">2</span>, v2);<br>mat.<span class="hljs-built_in">SetColumn</span>(<span class="hljs-number">3</span>, v3);<br><br><span class="hljs-keyword">return</span> std::<span class="hljs-built_in">move</span>(mat);<br>&#125;<br>    <span class="hljs-comment">//这里要先解析Point4&lt;T&gt;类型</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">to_json</span><span class="hljs-params">(json&amp; j, <span class="hljs-type">const</span> core::Matrix44&lt;T&gt;&amp; u)</span> </span>&#123;<br>core::Point4&lt;T&gt; v0 = u.<span class="hljs-built_in">GetColumn4</span>(<span class="hljs-number">0</span>);<br>core::Point4&lt;T&gt; v1 = u.<span class="hljs-built_in">GetColumn4</span>(<span class="hljs-number">1</span>);<br>core::Point4&lt;T&gt; v2 = u.<span class="hljs-built_in">GetColumn4</span>(<span class="hljs-number">2</span>);<br>core::Point4&lt;T&gt; v3 = u.<span class="hljs-built_in">GetColumn4</span>(<span class="hljs-number">3</span>);<br>j[<span class="hljs-string">&quot;value0&quot;</span>] = v0;<br>j[<span class="hljs-string">&quot;value1&quot;</span>] = v1;<br>j[<span class="hljs-string">&quot;value2&quot;</span>] = v2;<br>j[<span class="hljs-string">&quot;value3&quot;</span>] = v3;<br>&#125;<br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中，<code>adl_serializer</code>的使用说明详见：<a href="https://json.nlohmann.me/api/adl_serializer/">adl_serializer使用说明</a></p><p>最后，再<code>foo.cpp</code>中引入头文件<code>jsonPrarse.h</code>就可以实现解析操作</p><ul><li>使用方法为：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;jsonPrarse.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;CoefficientInfo.h&quot;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Coefficient</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">parseConfigCoefficient</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; path, CoefficientInfo&amp; coefficientInfo)</span></span><br><span class="hljs-function">    </span>&#123;<br>        JsonParse&lt;CoefficientInfo&gt;::<span class="hljs-built_in">fromJson</span>(path, coefficientInfo);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>就可以将path路径下的json文件解析到coefficientInfo成员变量中</li></ul><h2 id="4-使用宏扩展"><a href="#4-使用宏扩展" class="headerlink" title="4.使用宏扩展"></a>4.使用宏扩展</h2><p>再结构体内部使用宏<code>NLOHMANN_DEFINE_TYPE_INTRUSIVE_WITH_DEFAULT</code>就可以构造<code>from_json </code>和 &#96;&#96;to_json&#96;&#96;&#96;两个函数，用法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">OrderMeshEx</span><br>&#123;<br><span class="hljs-type">int</span> x;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; vec;<br>    Matrix mat;<br><span class="hljs-built_in">NLOHMANN_DEFINE_TYPE_INTRUSIVE_WITH_DEFAULT</span>(OrderMeshEx, x,vec,mat)<br>&#125;;<br></code></pre></td></tr></table></figure><p>注意对于自定义类型，还是需要自己写构造方式和解析方式，也即映入头文件<code>jsonPrarse.h</code>。</p><p>具体宏的其实使用手法参见：<a href="https://json.nlohmann.me/features/arbitrary_types/#simplify-your-life-with-macros">宏说明</a></p><h2 id="5-继承，组合使用"><a href="#5-继承，组合使用" class="headerlink" title="5.继承，组合使用"></a>5.继承，组合使用</h2><p>有时候我们需要在别人的结构体上添加字段，但是又没有别人的源码（或者无法修改），此时可以考虑使用类继承的方式构造</p><p>拿前宏的案例来说明：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">DataInfo</span><br>&#123;<br>std::vector&lt;<span class="hljs-type">int</span>&gt; nums;<br><span class="hljs-type">float</span> val;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">to_json</span><span class="hljs-params">(nlohmann::json&amp; j, <span class="hljs-type">const</span> DataInfo&amp; d)</span> </span>&#123;<br>j[<span class="hljs-string">&quot;val&quot;</span>] = d.val;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; d.nums.<span class="hljs-built_in">size</span>(); ++i)<br>&#123;<br>j[<span class="hljs-string">&quot;nums&quot;</span>][i] = d.nums[i];<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">from_json</span><span class="hljs-params">(<span class="hljs-type">const</span> nlohmann::json&amp; j, DataInfo&amp; d)</span> </span>&#123;<br>d.val = j[<span class="hljs-string">&quot;val&quot;</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; d.nums.<span class="hljs-built_in">size</span>(); ++i)<br>&#123;<br>d.nums[i] = j[<span class="hljs-string">&quot;nums&quot;</span>][i];<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">A</span> <br>&#123;<br><span class="hljs-type">double</span> Aa;<br><span class="hljs-type">double</span> Ab;<br><span class="hljs-built_in">NLOHMANN_DEFINE_TYPE_INTRUSIVE_WITH_DEFAULT</span>(A, Aa, Ab);<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">B</span> : <span class="hljs-keyword">public</span> A <br>&#123;<br><span class="hljs-type">int</span> Ba;<br><span class="hljs-type">int</span> Bb;<br>DataInfo Bc;<br><span class="hljs-built_in">NLOHMANN_DEFINE_TYPE_INTRUSIVE_WITH_DEFAULT</span>(B, Aa, Ab, Ba, Bb, Bc);<br>&#125;;<br></code></pre></td></tr></table></figure><p>此处，我们使用了B类，并继承类A，然后添加了三个成员变量，其中一个为自定义类型。<br>若只是添加普通类型，则直接使用默认宏就行。但是对于<em>自定义类型</em>，我们需要编写解析方式。且位于<strong>使用宏之前</strong>。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>testPage</title>
    <link href="/myblog.github.io/2024/07/02/testPage/"/>
    <url>/myblog.github.io/2024/07/02/testPage/</url>
    
    <content type="html"><![CDATA[<h2 id="这是一个测试页面"><a href="#这是一个测试页面" class="headerlink" title="这是一个测试页面"></a>这是一个测试页面</h2><img src="/myblog.github.io/2024/07/02/testPage/MyPhoto.jpg" class="" title="MyPhoto">]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
